{"version":3,"file":"crossword_clue.min.js","sources":["../src/crossword_clue.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Crossword clue class, handle any action relative to clue.\n *\n * @module qtype_crossword/crossword_clue\n * @copyright 2022 The Open University\n * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {CrosswordQuestion} from 'qtype_crossword/crossword_question';\n\nexport class CrosswordClue extends CrosswordQuestion {\n\n    /**\n     * Constructor.\n     *\n     * @param {Object} options The settings for crossword.\n     */\n    constructor(options) {\n        super(options);\n    }\n\n    /**\n     * Set up for clue section.\n     */\n    setUpClue() {\n        let {words, readonly} = this.options;\n        const clueEls = this.options.crosswordEl\n            .closest('.qtype_crossword-grid-wrapper')\n            .querySelectorAll('.contain-clue .wrap-clue');\n        clueEls.forEach(el => {\n            const questionId = el.dataset.questionid;\n            let word = words.find(o => o.number === parseInt(questionId));\n            if (word) {\n                const inputEl = el.querySelector('input');\n                // Retrieve special characters list.\n                const ignoreIndexes = this.getIgnoreIndexByAnswerNumber(word.number, false);\n                const wordString = this.makeUnderscore(word.length - inputEl.value.length);\n                // Add special characters to the answer, then set it to the answer input.\n                inputEl.value += this.mapAnswerAndSpecialLetter(wordString, ignoreIndexes[0]);\n                if (!readonly) {\n                    inputEl.disabled = false;\n                }\n                // Add event for input.\n                this.addEventForClueInput(inputEl, word);\n            }\n        });\n    }\n\n    /**\n     * Add event to word input element.\n     *\n     * @param {Element} el The input element.\n     * @param {String} word The word data.\n     */\n    addEventForClueInput(el, word) {\n        const {readonly} = this.options;\n        let startSelection = 0;\n        if (readonly) {\n            return;\n        }\n        el.addEventListener('click', (e) => {\n            // This regex matches strings that only contain space and underscores.\n            // That mean user has not fill any word.\n            const blankAnswer = /^[ _-]+$/.test(e.target.value);\n            const isCursorAtTheEnd = e.target.selectionEnd === e.target.value.length;\n            let startIndex = e.target.selectionStart;\n            // Check if the answer fields is clicked.\n            const isClicked = startIndex === e.target.selectionEnd;\n            // Cursor will move to the start of the clue field if the input is blank.\n            if (blankAnswer && isCursorAtTheEnd && isClicked) {\n                startIndex = 0;\n            }\n\n            const previousIndex = startIndex - 1;\n            // Check if the previous character contains hyphen or space.\n            const isContainSpecialCharacter = ['-', ' '].includes(e.target.value.charAt(previousIndex));\n            if (!isContainSpecialCharacter && isClicked) {\n                startIndex = (previousIndex < 0) ? 0 : previousIndex;\n                e.target.setSelectionRange(startIndex, startIndex);\n            }\n\n            // Based on the selected letter index on the answer index,\n            // we will find the corresponding crossword cell index.\n            const {words} = this.options;\n            const wordNumber = e.target.closest('.wrap-clue').dataset.questionid;\n            const wordObj = words.find(o => o.number === parseInt(wordNumber));\n            startIndex = this.findCellIndexFromAnswerIndex(wordObj, startIndex);\n            this.focusCellByStartIndex(startIndex, word);\n            this.focusClue();\n            this.setStickyClue();\n        });\n\n        el.addEventListener('focus', (e) => {\n            e.target.dispatchEvent(new Event('click'));\n        });\n\n        el.addEventListener('beforeinput', (e) => {\n            if (e.inputType === 'insertText' && e.data) {\n                this.handleInsertedCharacterToElement(e, e.data);\n            }\n        });\n\n        el.addEventListener('input', (e) => {\n            // Handling the event when the user selects the backspace or delete button.\n            if (e.inputType === 'deleteContentBackward' ||\n                    e.inputType === 'deleteContentForward') {\n                this.handleAndSyncDeletedStringToElement(e.target, e.target.value);\n            }\n        });\n\n        el.addEventListener('keypress', (e) => {\n            e.preventDefault();\n            // On mobile devices, the Backspace key may trigger the keypress event when the user uses Input Method Editor.\n            // Therefore, we need to prevent this behavior.\n            if (e.key === this.BACKSPACE) {\n                return;\n            }\n            this.handleInsertedCharacterToElement(e, e.key);\n        });\n\n        el.addEventListener('compositionstart', (evt) => {\n            startSelection = evt.target.selectionStart;\n            // The steps below fix the issue when the user selects all the value of the input text,\n            // and then enters a letter from the IME keyboard. In this case, we should only remove\n            // the first letter of the selected value instead of removing all of them.\n            // To achieve this, we will follow these steps:\n            // 1. Retrieve the current value of the input.\n            let value = evt.target.value.split('');\n            // 2. Remove a letter of the input value based on the letter index.\n            value.splice(startSelection, 1);\n            // 3. Set the updated value back to the input text.\n            evt.target.value = value.join('');\n            evt.target.setSelectionRange(startSelection, startSelection);\n        });\n\n        el.addEventListener('compositionend', (evt) => {\n            evt.preventDefault();\n            evt.stopPropagation();\n            const {wordNumber} = this.options;\n            const selection = evt.target.selectionStart;\n            let key = evt.data.normalize('NFKC');\n            evt.target.setSelectionRange(selection, selection);\n            this.insertCharacters(evt, key, wordNumber, word, startSelection);\n        });\n\n        el.addEventListener('keyup', (event) => {\n            event.preventDefault();\n            const {words, wordNumber} = this.options;\n            const {key, target} = event;\n            let {value} = target;\n            let isValidKey = false;\n            let maxLength = parseInt(target.getAttribute('maxlength'));\n            if ([this.ARROW_LEFT, this.ARROW_RIGHT].includes(key)) {\n                isValidKey = true;\n                const word = words.find(o => o.number === parseInt(wordNumber));\n                // Based on the selected letter index of the answer input,\n                // we will find the cell with the corresponding letter index attribute.\n                const startIndex = this.findCellIndexFromAnswerIndex(word, target.selectionStart, false);\n                const gEl = this.options.crosswordEl\n                    .querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\n                if (gEl) {\n                    this.toggleHighlight(word, gEl);\n                }\n            }\n\n            if (key === this.END || key === this.HOME || key === this.ARROW_UP || key === this.ARROW_DOWN) {\n                isValidKey = true;\n                let startIndex = 0;\n                const word = words.find(o => o.number === parseInt(wordNumber));\n                if (!word) {\n                    return;\n                }\n                if (key === this.END || key === this.ARROW_DOWN) {\n                    startIndex = word.length - 1;\n                }\n                this.syncFocusCellAndInput(target, startIndex);\n            }\n\n            if (!isValidKey && startSelection >= maxLength) {\n                event.target.value = value.slice(0, maxLength);\n            }\n        });\n\n        el.addEventListener('paste', (event) => {\n            event.preventDefault();\n            const {words, wordNumber} = this.options;\n            const word = words.find(o => o.number === parseInt(wordNumber));\n            let selection = event.target.selectionStart;\n            let value = (event.clipboardData || window.clipboardData).getData('text');\n            let ignoreIndexes = this.getIgnoreIndexByAnswerNumber(word.number);\n            // Remove invalid characters, normarlize NFKC.\n            value = this.replaceText(value).normalize('NFKC');\n            if (value === '') {\n                return;\n            }\n            let letterIndex = 1;\n            value.split('').every(char => {\n                // Stop function If the character overflows.\n                if (letterIndex > word.length - ignoreIndexes.length) {\n                    return false;\n                }\n                const result = this.handleTypingData(event, wordNumber, word, selection, char);\n                letterIndex++;\n                // Find the valid index.\n                if (result) {\n                    for (let index = selection + 1; index < word.length; index++) {\n                        if (!ignoreIndexes.includes(index)) {\n                            selection = index;\n                            break;\n                        }\n                    }\n                }\n                return true;\n            });\n        });\n\n        el.addEventListener('keydown', (e) => {\n            if (e.ctrlKey && e.key.toLowerCase() === this.Z_KEY) {\n                e.preventDefault();\n            }\n            if (e.key === this.ENTER) {\n                e.preventDefault();\n            }\n        });\n\n        el.addEventListener('cut', (event) => {\n            const selectString = document.getSelection().toString();\n            const startIndex = event.target.selectionStart;\n            let {value} = event.target;\n            value = value.substring(0, startIndex) +\n                value.substring(startIndex + selectString.length) +\n                this.makeUnderscore(selectString.length);\n            event.target.value = value;\n            event.clipboardData.setData('text/plain', selectString);\n            event.preventDefault();\n            event.target.setSelectionRange(startIndex, startIndex);\n            // In case the user cuts off the entire answer, we need to update the crossword grid.\n            this.syncLettersByText(value, false);\n        });\n    }\n\n    /**\n     * Handle typing data.\n     *\n     * @param {Object} evt Event data.\n     * @param {Number} wordNumber The word number.\n     * @param {Object} word The word object.\n     * @param {Number} selectionIndex The position of cursor selection.\n     * @param {String} char The character.\n     *\n     * @return {Boolean} True if the data is valid.\n     */\n    handleTypingData(evt, wordNumber, word, selectionIndex, char) {\n        const [count, gEl] = this.findTheClosestCell(wordNumber, word, selectionIndex);\n        if (this.replaceText(char) === '') {\n            return false;\n        }\n        if (gEl) {\n            gEl.querySelector('text.crossword-cell-text').innerHTML = char.toUpperCase();\n            this.bindDataToClueInput(gEl, char.toUpperCase());\n        }\n\n        // Go to next letter.\n        const [letterIndex, nexEl] = this.findTheClosestCell(wordNumber, word, count + 1);\n        if (nexEl) {\n            this.toggleHighlight(word, nexEl);\n            evt.target.setSelectionRange(letterIndex, letterIndex);\n        }\n        return true;\n    }\n\n    /**\n     * Focus cell base on the start index.\n     *\n     * @param {Element} startIndex The start index.\n     * @param {String} word The word data.\n     */\n    focusCellByStartIndex(startIndex, word) {\n        let position = this.calculatePosition(word, startIndex);\n        const rect = this.options.crosswordEl.querySelector(`g rect[x='${position.x}'][y='${position.y}']`);\n        if (rect) {\n            this.options.wordNumber = word.number;\n            this.toggleHighlight(word, rect.closest('g'));\n            this.updateLetterIndexForCells(word);\n        }\n    }\n\n    /**\n     * Focus crossword cell from the start index.\n     *\n     * @param {Element} target The element.\n     * @param {Number} startIndex The start index.\n     */\n    syncFocusCellAndInput(target, startIndex) {\n        const {wordNumber} = this.options;\n        const gEl = this.options.crosswordEl.querySelector(`g[data-word*='(${wordNumber})'][data-letterindex='${startIndex}']`);\n        target.setSelectionRange(startIndex, startIndex);\n        if (gEl) {\n            this.toggleFocus(gEl);\n        }\n    }\n\n    /**\n     * Toggle the focus cell.\n     *\n     * @param {Element} gEl The word letter.\n     */\n    toggleFocus(gEl) {\n        const focused = this.options.crosswordEl.querySelector('g rect.crossword-cell-focussed');\n        if (focused) {\n            focused.classList.remove('crossword-cell-focussed');\n            focused.classList.add('crossword-cell-highlighted');\n        }\n        gEl.querySelector('rect').classList.add('crossword-cell-focussed');\n    }\n\n    /**\n     *\n     * Add underscore to deleted string and sync it to crossword clue input.\n     *\n     * @param {Element} target The element target\n     * @param {String} value the string input after we deleted single or multiples character.\n     */\n    handleAndSyncDeletedStringToElement(target, value) {\n        const {words, wordNumber} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        if (!word) {\n            return;\n        }\n        let startIndex = target.selectionStart;\n        let selectionLength = word.length - value.length;\n        // When the user enters characters using an Input Method Editor, sometimes they may exceed the maximum length allowed.\n        // We need to reset it to prevent obtaining a negative number.\n        if (selectionLength < 0) {\n            selectionLength = 0;\n        }\n        const underScore = this.makeUnderscore(selectionLength);\n        // Insert underscore to deleted string.\n        // We need to ensure that the value does not exceed the maximum allowed length.\n        target.value = [value.slice(0, startIndex), underScore, value.slice(startIndex)].join('').slice(0, word.length);\n        // In case the user deletes the entire answer we need to update the crossword grid.\n        this.syncLettersByText(target.value, false);\n        this.syncFocusCellAndInput(target, startIndex);\n    }\n\n    /**\n     * Insert the character to clue input.\n     *\n     * @param {Object} event Event data.\n     * @param {String} value the character we are inserted to the clue input.\n     */\n    handleInsertedCharacterToElement(event, value) {\n        const {words, wordNumber} = this.options;\n        const word = words.find(o => o.number === parseInt(wordNumber));\n        let startIndex = event.target.selectionStart;\n        value = this.replaceText(value).normalize('NFKC');\n        if (value === '') {\n            return;\n        }\n        event.target.setSelectionRange(startIndex, startIndex);\n        this.insertCharacters(event, value, wordNumber, word, startIndex);\n    }\n\n    /**\n     * When the user enters characters using an Input Method Editor (IME),\n     * the input value can consist of multiple characters instead of just one. Therefore, we need to loop through them and\n     * insert them into the answer input.\n     *\n     * @param {Object} event Event data.\n     * @param {String} value The characters we are inserted to the clue input.\n     * @param {Number} wordNumber The word number.\n     * @param {Object} word The word object.\n     * @param {Number} currentSelection The position of cursor.\n     */\n    insertCharacters(event, value, wordNumber, word, currentSelection) {\n        // Retrieve the special character index of word.\n        // e.g: Answer is: A-B-C, so the list special character index is: [1,3].\n        const ignoreIndexes = this.getIgnoreIndexByAnswerNumber(wordNumber);\n        const chars = value.split('');\n        // If the current selection index is greater than the word length or\n        // if we have already handled all the characters, we need to stop the loop.\n        while (currentSelection < word.length && chars.length !== 0) {\n            // Skip handling special characters.\n            if (!ignoreIndexes.includes(currentSelection)) {\n                // Handle each character.\n                this.handleTypingData(event, wordNumber, word, currentSelection, chars.shift());\n            }\n            // We have to increase the selection index until we encounter a valid letter (excluding special characters).\n            currentSelection++;\n        }\n        requestAnimationFrame(() => {\n            // If the current selection is a special character,\n            // we need to increase the selection index to find the next valid character.\n            if (ignoreIndexes.includes(currentSelection)) {\n                currentSelection++;\n            }\n            // Set the selection range.\n            event.target.setSelectionRange(currentSelection, currentSelection);\n        });\n    }\n}\n"],"names":["CrosswordClue","CrosswordQuestion","constructor","options","setUpClue","words","readonly","this","crosswordEl","closest","querySelectorAll","forEach","el","questionId","dataset","questionid","word","find","o","number","parseInt","inputEl","querySelector","ignoreIndexes","getIgnoreIndexByAnswerNumber","wordString","makeUnderscore","length","value","mapAnswerAndSpecialLetter","disabled","addEventForClueInput","startSelection","addEventListener","e","blankAnswer","test","target","isCursorAtTheEnd","selectionEnd","startIndex","selectionStart","isClicked","previousIndex","includes","charAt","setSelectionRange","wordNumber","wordObj","findCellIndexFromAnswerIndex","focusCellByStartIndex","focusClue","setStickyClue","dispatchEvent","Event","inputType","data","handleInsertedCharacterToElement","handleAndSyncDeletedStringToElement","preventDefault","key","BACKSPACE","evt","split","splice","join","stopPropagation","selection","normalize","insertCharacters","event","isValidKey","maxLength","getAttribute","ARROW_LEFT","ARROW_RIGHT","gEl","toggleHighlight","END","HOME","ARROW_UP","ARROW_DOWN","syncFocusCellAndInput","slice","clipboardData","window","getData","replaceText","letterIndex","every","char","result","handleTypingData","index","ctrlKey","toLowerCase","Z_KEY","ENTER","selectString","document","getSelection","toString","substring","setData","syncLettersByText","selectionIndex","count","findTheClosestCell","innerHTML","toUpperCase","bindDataToClueInput","nexEl","position","calculatePosition","rect","x","y","updateLetterIndexForCells","toggleFocus","focused","classList","remove","add","selectionLength","underScore","currentSelection","chars","shift","requestAnimationFrame"],"mappings":"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"}